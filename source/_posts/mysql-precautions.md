---
title: MySQL注意事项
date: 2019-12-03 11:03:07
categories: 
- MySQL
tags:
- MySQL
description: SQL语句的注意事项
---
#### 数据模型与索引设计

1. ##### 字符集

    一般使用`utf8`，需要使用表情时使用`utf8mb4`。排序规则一般使用`utf8_general_ci`。
    排序规则：
    - `_cs`：区分大小写
    - `_ci`：不区分大小写
    - `_bin`：以二进制数据存储，且区分大小写

2. ##### 索引

   1. 最左前缀匹配原则

       > 联合索引可以用于包含索引中所有列的查询条件的语句, 或者包含索引中的前N列

   2. 覆盖索引

       > 从非聚簇索引中就能查到的记录，而不需要查询聚簇索引中的记录，避免了回表的产生减少了树的搜索次数，显著提升性能。

       - 聚簇索引：按创建索引时指定的列的顺序物理地排列表内容
       - 非聚簇索引：由索引键和指定数据块的标记组成

   3. 索引列设置为NOT NULL,否则会全表扫描

#### 查询数据

1. ##### 过滤与查找数据

    1. 查找不匹配或缺失的记录

        > 在子查询返回结果集大的时候使用`EXISTS`通常比`IN`更快，另一种是`LEFT JOIN`结合`WHERE`。

        - `EXISTS`：数据库引擎在找到第一行会停止运行子查询
        - `IN`：数据库引擎会检索所有行

    2. 按时间范围正确地过滤日期和时间

        1. 不要依赖隐式日期转换，使用显式转换函数`CONVERT()`来处理日期字符。
        2. 不要将函数应用于日期和时间列，否则查询不能使用索引。
        3. 舍入误差可能导致日期和时间值不正确。使用`>=`和`<`代替`BETWEEN`。可以使用`DATEADD()`


    3. 书写可参数化搜索的查询以确保引擎使用索引

        1. 使用`=`、`>`、`<`、`>=`、`<=`、`BETWEEN`、`ISNULL`、`LIKE`(不包括前导通配符)。
        2. 不要再`WHERE`子句中的一个或多个字段上使用函数。
        3. 不要对`WHERE`子句中的字段进行算术运算。

2. ##### 聚合

    1. 理解GROUP BY工作原理
    
        1. `FROM`子句生成数据集
        2. `WHERE`子句过滤由`FROM`子句生成的数据集
        3. `GROUP BY`子句聚合由`WHERE`子句过滤的数据集
        4. `HAVING`子句过滤由`GROUP BY`子句聚合的数据集
        5. `SELECT`子句转换过滤的聚合数据集
        6. `ORDER BY`子句对变换后的数据集进行排序

    2. 使用OUTER JOIN时避免获取错误的COUNT()

        > 数据库版本没有`RANK()`函数时，可以使用`COUNT()`子查询来实现。

        1. 使用`COUNT(*)`来统计所有记录的总数，也包括空值的记录。
   
        2. 使用`COUNT()`仅统计列值不为NULL的记录的总数。

        3. 有时一个子查询甚至一个关联子查询也会比`GROUP BY`更有效率。

        > 关联子查询: 子查询中的部分条件依赖于外部查询中正在处理的当前记录值。

    3. 避免使用GROUP BY来查找最大或最小值

        > 使用`LEFT JOIN`自身以及`WHERE`来查询，`ON`子句的列添加索引

    4. GROUP_COUNT()中也可以使用ORDER BY

注意：

1. Limit偏移量大时可以先单独查询Id再关联，或者记录上次查询的最大Id。

2. 对于MAX()和MIN()函数可以考虑使用ORDER BY和LIMIT 1代替。

3. 确保GROUP BY和ORDER BY只涉及一个表中的字段，这样才可能使用索引。

4. GROUP BY会自动按照分组的字段升序排序，可直接使用DESC和ASC排序，使用ORDER BY NULL不进行排序。

5. GROUP BY * WITH ROLLP得到每个分组以及每个分组汇总级别的值。

6. 一旦使用DISTINCT和GROUP BY需要产生临时表。

7. 复杂的`OR`条件可以使用多条`SELECT`语句和连接它们的`UNION`语句。
   
8.  如果无需去重请使用`UNOIN ALL`，`UNION`如果需要排序只需要在最后一条语句上使用`ORDER BY`。
   
9.  如果数据检索是最重要的，则你可以通过在INSERT和INTO之间添加关键字LOW_PRIORITY，指示MySQL降低INSERT语句的优先级，如`INSERT LOW_PRIORITY INTO`。

---

参考：
- Effective SQL 编写高质量SQL语句的61个有效方法
- Java工程师修炼之道