---
title: 设计模式
date: 2020-12-11 10:47:25
keywords: 设计模式
categories: 
- Note
tags:
- Note
description: 设计模式就是设计范例。模式不是框架(Franmework)，也不是过程，是典型问题的解决方案。模式具有一般性、简单性、重复性、结构性、稳定性和可操作性等特征。
---

GoF的23钟设计模式根据模式所完成的工作类型来划分，模式可分为创建型模式、结构性模式和行为型模式。

#### 创建型模式

> 用于描述"怎样创建对象"，主要特点是"将对象的创建与使用分离"。

- ##### 单例(Singleton)模式

    某个类只能生成一个实例，该类提供了一个全局访问点，以便外部获取该实例，其扩展是有限多例模式。

- ##### 原型(Prototype)模式

    将一个对象作为原型，通过对其进行复制操作而复制出多个和原型类似的新实例。

- ##### 工厂方法(Factory Method)模式

    定义一个用于创建产品的接口，由子类决定生产什么产品。

- ##### 抽象工厂(AbstractFactory)模式

    提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。

- ##### 建造者(Builder)模式

    将一个复杂对象分解成多个相对简单的部分，然后根据不同的需求分别创建它们，最后构建成该复杂对象。

#### 结构型模式

> 用于描述如何将类或对象按某种布局组成更大的结构。

- ##### 代理(Proxy)模式

    为某对象提供一种代理以控制该对象的访问，即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象地一些特征。

- ##### 适配器(Adapter)模式

    将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。

- ##### 桥接(Bridge)模式

    将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。

- ##### 装饰(Decorator)模式

    动态地给对象增加一些职责，即增加其额外的功能。

- ##### 外观(Facade)模式

    为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。

- ##### 享元(Flyweight)模式

    运用共享技术来有效地支持大量细粒度对象的复用。

- ##### 组合(Composite)模式

    将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

#### 行为型模式

> 用于描述类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责。

- ##### 模板方法(TemplateMethod)模式

    定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使子类可以在不改变该算法结构的情况下，重定义该算法的某些特定步骤。

- ##### 策略(Strategy)模式

    定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。

- ##### 命令(Command)模式

    将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分隔开。

- ##### 职责链(Chain of Responsibility)模式

    把请求从链中的一个对象传到以一个对象，直到请求被相应为止。通过这种方式可以去除对象之间的耦合。

- ##### 状态(State)模式

    允许一个对象在其内部状态发生改变时改变其行为能力。

- ##### 观察者(Observer)模式

    多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。

- ##### 中介者(Mediator)模式

    定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。

- ##### 迭代器(Iterator)模式

    提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。

- ##### 访问者(Visitor)模式

    在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。

- ##### 备忘录(Memento)模式

    在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。

- ##### 解释器(Interpreter)模式

    提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

#### 广义的设计模式

- #### 拦截器模式(Interceptor Pattern)

    提供一种通用的扩展机制，可以在业务操作前后提供一些切面(Cross-Cutting)的操作。
    在功能上，拦截器模式和面向切面编程(Aspect Oriented Programming, AOP)的思想很相似。不同于Java的动态代理是利用Java反射机制的，拦截器模式完全是利用面向对象技术的，巧妙地使用组合模式外加递归调用实现了灵活、可扩展地前置处理和后置处理。

- #### 插件模式(plug-in)

    和普通的对象扩展方式的不同之处在于，普通的扩展发生在软件内部，插件式扩展发生在软件外部。
    插件模式的实现原理和策略模式类似，要求主程序中做好扩展点接口的定义，然后在插件中进行扩展实现。

- #### 管道模式
  
    把处理过程进行划分，把不同的处理分配在不同的阀门上，最后组合起来形成管道。一般使用一个单向链表数据结构来实现。其实在功能上，拦截器、管道、过滤器、责任链有类似之处。
    一个典型的管道模式，会涉及三个主要角色：
    
    1. 阀门(Valve)：处理数据的节点。
    2. 管道(Pipeline)：组织各个阀门。
    3. 客户端：构造管道并调用。
